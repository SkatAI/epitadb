Needs proofing
- update 1st example to normalized v03 db
- add steps on 2nd example
- simplify 3rd example if wanted

# window functions applied to the trees table

The goal of this worksheet is to practice using window functions and CTEs on the treesdb ddatabase.

We work on the normalized version of the database treesdb_v03.
or the denormalized table treesdb_v02

You are a newly recruited analyst working in the Paris administration for parks.
You are given this dataset of trees in Paris and vicinity.

Your task is to 1. improve the dataset 2. explore the data to facilitate tree management

# Load the data

Connect to your local server (terminal + psq, or pgAdmin) to see if you have already created the treesdb_v02 database.

If not get the file from github and restore it into a new treesdb_v02 db.

## Load the dataset

You can download the data csv SQL file called ```treesdb_v02.01.sql.backup``` from the github repo.

- if you have already cloned the repo, refresh it with ```git pull origin master```
- if you haven't done so already: ```git clone git@github.com:SkatAI/epitadb.git```  and ```cd epitadb```
- or simply go to https://github.com/SkatAI/epitadb/tree/master/data and click right on the ```treesdb_v02.01.sql.backup``` file to download it

## Restore the data

Create a new treesdb_v02

in the terminal, restore the database  with

```bash
pg_restore ...
```

Change the owner if needded and the path to the downloaded file on your local.

# Stage does not make sense

You are not satisfied with the values in the ```stage``` column which are

```sql
select count(*) as n, stage from trees group by stage order by n desc;
   n   |        stage
-------+---------------------
 79627 | Adulte
 46742 | [null]
 38915 | Jeune (arbre)
 38765 | Jeune (arbre)Adulte
  7290 | Mature
```

Many null values and it's not clear what ```Jeune (arbre)Adulte``` means. Is it a Jeune or an Adulte tree ?

So we want to replace the stage by
For each tree we want to calculate the max height for its type : genre, species, variety
and create a new stage column that depends on the ratio of height over max_height

In the following we will assume that tree growth is linear (although that's [debatable](https://www.reddit.com/r/askscience/comments/eyf3ar/is_tree_growth_linear_or_do_younger_trees_grow/))

Our goal for a given tree type (genre, species and variety)  and related max_height is to set

| ratio = height / max_height | new stage |
| ------  | ------- |
| ratio < 0.25  | young |
| 0.25 <= ratio  < 0.5  | young adult |
| 0.5 <= ratio  < 0.75  | adult |
| 0.75 <= ratio   | mature |

These threshold are arbitrary and probably do not reflect reality.


1. max height per tree type

write a query to calculate the max(height) per type of tree
* a tree type is defined by its genre, species, variety
* only consider not null genre, speciesor variety
* for each tree return the columns: id, genre, species, variety, height and max_height

You can limit the number of rows by filtering on a domain (  51142 | Jardin ) and adding limits.

```sql
select t.id, t.genre, t.species, t.variety, t.height,
max(height) over(partition by genre, species, variety) as max_height
from trees t
where t.genre is not null
and t.species is not null
and t.variety is not null
and t.domain = 'Jardin'
order by genre, species, variety;
```

2. Add new_stage column

Then create a new text column called ```new_stage``` with data type VARCHAR(50).

To add a column to an existing table the query follows

ALTER TABLE table_name ADD COLUMN column_name VARCHAR(50);

3. fill new_stage with the right designation : young, young adult, adult, mature

Use the query above as a named subquery to update the new_stage columnn with the derived new stage designation.

```sql
WITH get_stage  gt AS (
        select t.id, t.genre, t.species, t.variety, t.height,
        max(height) over(partition by genre, species, variety) as max_height
        from trees t
        where t.genre is not null
        and t.species is not null
        and t.variety is not null
        and t.domain = 'Jardin'
        order by genre, species, variety
)
UPDATE trees t
SET new_stage = CASE
    WHEN gt.height < 0.25 * gt.max_height THEN 'young'
    WHEN gt.height < 0.50 * gt.max_height THEN 'young adult'
    WHEN gt.height < 0.75 * gt.max_height THEN 'adult'
    ELSE 'mature'
END
FROM get_stage gt
WHERE t.id = gt.id;
```

Write a query that implements the rule

```
if height < 0.25 * max_height then new_stage = 'young'
elif height < 0.50 * max_height then new_stage = 'young adult'
elif height < 0.75 * max_height then new_stage = 'adult'
elif height >= 0.75 * max_height then new_stage = 'mature'
```

Hiint: You can use the query structure

```sql
WITH temp AS (
        -- some SQL query
)
UPDATE table_name
SET column_name = CASE
    WHEN (some cond 1) THEN 'label 1'
    WHEN (some cond 2) THEN 'label 2'
    ELSE 'other label'
END
from temp
where temp.id = table_name.id;
```


4. Is that new_stage in accordance with the original stage values ?


# Find tall and large trees

The climate change office of the  Paris Mairie wants to find the largest and tallest trees in Paris. Because large trees provide shelter from the heat  during heat waves. So they can study them and find what's driving their growth.

They ask you to provide the following list:

For each arrondissement, find the top 3 tallest trees.
and for each tree  include
- id, height, circumference,
- circumference rank in their arrondissement
- height rank over similar trees in Paris
- domain and stage


```sql
WITH ranked_trees AS (
    SELECT
        t.id,
        l.arrondissement,
        t.height,
        t.circumference,
        ROW_NUMBER() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.height DESC
        ) AS height_rank_in_arrondissement,
        RANK() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.circumference DESC
        ) AS circumference_rank_in_arrondissement,
        RANK() OVER (
            ORDER BY t.height DESC
        ) AS overall_height_rank
    FROM trees t
    JOIN locations l ON t.location_id = l.id
)
SELECT
    arrondissement,
    tree_id,
    height,
    circumference,
    height_rank_in_arrondissement,
    circumference_rank_in_arrondissement,
    overall_height_rank
FROM ranked_trees
WHERE height_rank_in_arrondissement <= 3
ORDER BY arrondissement, height_rank_in_arrondissement;
```

# II find outliers

we want to find crazy values for heights

All trees of the same type (genre, species, variety) should have the same height range

so we're going to order the trees by genre, species, varierty and height
for each tree find the height in the previous row
if the height of the tree is double the previous height
flag the tree as outlier



1. use the lag function with default value the avg tree height we just calculated
order trees by genre, species, variety (not null)
and get the last row height

for default, specify the height column and not a numerical value. This will set the previous height as the same height of the current row.

2. create a new column outlier as boolean default FALSE

write the query that sets the value of outlier
if height > 2 * prev_height then outlier is True

3. inspect the results,

- does the threshold at 2 make sense ?


# CTEs on trees


For each arrondissement, find the top 3 tallest trees. Then, display these trees along with their circummference rank  within their arrondissement and their overall height rank in Paris.

```sql
WITH ranked_trees AS (
    SELECT
        l.arrondissement,
        t.idbase AS tree_id,
        t.height,
        t.circumference,
        ROW_NUMBER() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.height DESC
        ) AS height_rank_in_arrondissement,
        RANK() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.circumference DESC
        ) AS circumference_rank_in_arrondissement,
        RANK() OVER (
            ORDER BY t.height DESC
        ) AS overall_height_rank
    FROM trees t
    JOIN locations l ON t.location_id = l.id
)
SELECT
    arrondissement,
    tree_id,
    height,
    circumference,
    height_rank_in_arrondissement,
    circumference_rank_in_arrondissement,
    overall_height_rank
FROM ranked_trees
WHERE height_rank_in_arrondissement <= 3
ORDER BY arrondissement, height_rank_in_arrondissement;
```


It appears that name and genre are 1 to 1.
But some names are null for a given genre
For instance

  n   |     genre      |         name
-------+----------------+-----------------------
     2 | Abies          | [null]
   140 | Abies          | Sapin
     1 | Acacia         | [null]
    32 | Acacia         | Mimosa

How can we use CTEs to update the null values in the names column if there's a non null genre

```sql
WITH genre_name_mapping AS (
    SELECT
        tg.id AS genre_id,
        tg.genre,
        tn.id AS name_id,
        tn.name,
        ROW_NUMBER() OVER (PARTITION BY tg.genre ORDER BY tn.id) AS rn
    FROM tree_genres tg
    LEFT JOIN taxonomy tax ON tg.id = tax.genre_id
    LEFT JOIN tree_names tn ON tax.name_id = tn.id
),
valid_names AS (
    SELECT
        genre_id,
        genre,
        COALESCE(name, genre) AS valid_name
    FROM genre_name_mapping
    WHERE rn = 1
)
UPDATE tree_names tn
SET name = vn.valid_name
FROM taxonomy tax
JOIN valid_names vn ON tax.genre_id = vn.genre_id
WHERE tax.name_id = tn.id
  AND tn.name IS NULL;
```

# Further reading

CTEs on trees
https://claude.ai/chat/fb6b9a94-b819-458a-8466-fe65d7b939c1
