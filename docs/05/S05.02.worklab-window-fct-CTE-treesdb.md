
Needs proofing

- update 1st example to normalized v03 db
- add steps on 2nd example
- simplify 3rd example if wanted
- Should We work on the normalized version of the database `treesdb_v03` or the denormalized table `treesdb_v02`

# Lab on window functions and CTEs

The goal of this worksheet is to practice using window functions and CTEs on the `treesdb` database.

You are a newly recruited analyst working in the Paris administration for parks.
You are given this dataset of trees in Paris and vicinity.

Your task is to

1. improve the dataset
2. explore the data to facilitate tree management

## Load the data

We work on the denormalized version of the trees database that has only one tree table.

If you don't have this version of the tree database on your local, you need to create the database and restore the data.

First, connect to your local server (terminal + psql, or pgAdmin) to see if you have already created the `treesdb_v02` database. Create the `treesdb_v02` database if needed.

Then download the dataset: `treesdb_v02.01.sql.backup` file from [GitHub](https://github.com/SkatAI/epitadb/tree/master/data) and restore it into a newly created `treesdb_v02` db.

## Parti I: data quality and the stage column

You are not satisfied with the values in the ```stage``` column which are:

```sql
select count(*) as n, stage from trees group by stage order by n desc;
   n   |        stage
-------+---------------------
 79627 | Adulte
 46742 | [null]
 38915 | Jeune (arbre)
 38765 | Jeune (arbre)Adulte
  7290 | Mature
```

Too many null values and it's not clear what ```Jeune (arbre)Adulte``` really stands for. Is it a _jeune_ (young) or an _adulte_ tree?

So we want to replace the `stage` values by some new category that we will call `maturity`.

- For each tree we calculate the max height for its type (genre, species, variety).
- The ratio of height over max_height sets the `maturity`.

We assume that tree growth is linear (although that's [debatable](https://www.reddit.com/r/askscience/comments/eyf3ar/is_tree_growth_linear_or_do_younger_trees_grow/))

The maturity category for a given tree type (genre, species and variety) and related max_height is given by

| ratio = height / max_height | new stage |
| ------  | ------- |
| ratio < 0.25  | young |
| 0.25 <= ratio  < 0.5  | young adult |
| 0.5 <= ratio  < 0.75  | adult |
| 0.75 <= ratio   | mature |

These thresholds are totally arbitrary and may not reflect reality.

### 1. max height per tree type

You want to calculate the max(height) per type of tree.

- a tree type is defined by its genre, species
- only consider not null values for genre, species
- for each tree return the columns: `id`, `genre`, `species`, `height` and `max_height`

Hint: `partition by genre, species`

> Solution

```sql
select t.id, t.genre, t.species, t.height,
max(height) over(partition by genre, species) as max_height
from trees t
where t.genre is not null
and t.species is not null
order by genre, species;
```

### 2. Add a `maturity` column to the trees table

Create a new text column called ```maturity``` with data type VARCHAR(50).

To add a column to an existing table the query follows

```sql
ALTER TABLE table_name ADD COLUMN column_name VARCHAR(50);
```

> Solution

```sql
ALTER TABLE trees ADD COLUMN maturity VARCHAR(50);
```

### 3. fill maturity with the right value : young, young adult, adult, mature

Use the query above where you calculated max_height for each tree type as a named subquery to update the `maturity` column with the calculated maturity values.

Hint: use  CASE WHEN in your query to convert the ratio between height and max_height into a string. See [documentation](https://www.postgresql.org/docs/current/functions-conditional.html#FUNCTIONS-CASE)

> Solution

```sql
WITH get_maturity AS (
        select t.id, t.genre, t.species, t.height,
        max(height) over(partition by genre, species) as max_height
        from trees t
        where t.genre is not null
        and t.species is not null
        order by genre, species
)
UPDATE trees t
SET maturity = CASE
    WHEN gm.height < 0.25 * gm.max_height THEN 'young'
    WHEN gm.height < 0.50 * gm.max_height THEN 'young adult'
    WHEN gm.height < 0.75 * gm.max_height THEN 'adult'
    ELSE 'mature'
END
FROM get_maturity gm
WHERE t.id = gm.id;
```

Hint: You can use the query structure

```sql
WITH temp AS (
        -- some SQL query
)
UPDATE table_name
SET column_name = CASE
    WHEN (some cond 1) THEN 'label 1'
    WHEN (some cond 2) THEN 'label 2'
    ELSE 'other label'
END
from temp
where temp.id = table_name.id;
```

#### 4. Is that maturity in accordance with the original stage values ?

Although the original stage column is showing very poor data quality there should be some consistency between the new maturity categories and the original stage categories.

We should see small number of trees with diverging stage and maturity values:

- stage = 'Jeune' & maturity != 'young'
- stage = 'Adulte' & maturity != 'adulte'

Write a query that counts the percentage of trees where these 2 categories don't match.

- Use a CTE
- provide the percentage as a float with 2 decimals (use the ROUND() function)

> solution

```sql
WITH jeune AS (
    SELECT
        COUNT(*) AS total_records,
        stage, maturity,
        SUM(
            CASE WHEN stage = 'Jeune (arbre)' AND maturity != 'young' THEN 1 ELSE 0 END
        ) AS stage_jeune_mismatch,
        SUM(
            CASE WHEN maturity = 'young'  AND stage != 'Jeune (arbre)' THEN 1 ELSE 0 END
        ) AS maturity_jeune_mismatch
    FROM trees
    where stage = 'Jeune (arbre)'
    group by stage, maturity
)
WITH adulte AS (
    SELECT
        COUNT(*) AS total_records,
        stage, maturity,
        SUM(
            CASE WHEN stage = 'Adulte' AND maturity != 'adult' THEN 1 ELSE 0 END
        ) AS stage_jeune_mismatch,
        SUM(
            CASE WHEN maturity = 'adult'  AND stage != 'Adulte' THEN 1 ELSE 0 END
        ) AS maturity_jeune_mismatch
    FROM trees
    where stage = 'Adulte'
    group by stage, maturity
)


SELECT stage, maturity,
    (stage_jeune_mismatch::float / total_records * 100) AS stage_jeune_mismatch_pct,
    (maturity_jeune_mismatch::float / total_records * 100) AS maturity_jeune_mismatch_pct
FROM counts
where stage = 'Jeune (arbre)' OR maturity = 'young';
```

```sql
select count(*) as n, genre, species, variety
from trees
where stage = 'Adulte'
and maturity is null
group by genre, species, variety
order by genre, species, variety, n desc;
```

## Part II: Find tall and large trees

The climate change office of the  Paris Mairie wants to find the largest and tallest trees in Paris. Because large trees provide shelter from the heat during heat waves.

They ask you to provide the following list:

For each arrondissement, find the top 3 tallest trees.
and for each tree include

- id, height, circumference,
- circumference rank in their arrondissement
- height rank over similar trees in Paris
- domain and stage

```sql
WITH ranked_trees AS (
    SELECT
        id,
        arrondissement,
        height,
        MAX(height) OVER (
            PARTITION BY arrondissement
            ORDER BY height DESC
        ) AS max_height_in_arrondissement,
        DENSE_RANK() OVER (
            PARTITION BY arrondissement
            ORDER BY height DESC
        ) AS height_rank_in_arrondissement,
        DENSE_RANK() OVER (
            ORDER BY height DESC
        ) AS overall_height_rank
    FROM trees t
    where genre = 'Pinus'
)
SELECT *
FROM ranked_trees
WHERE height_rank_in_arrondissement <= 3
ORDER BY arrondissement, height_rank_in_arrondissement;
```

# II find outliers

we want to find crazy values for heights

All trees of the same type (genre, species, variety) should have the same height range

so we're going to order the trees by genre, species, variety and height
for each tree find the height in the previous row
if the height of the tree is double the previous height
flag the tree as outlier

would make sense to also flag other trees with same type and higher heights as outliers

1. use the lag function with default value the avg tree height we just calculated
order trees by genre, species, variety (not null)
and get the last row height

for default, specify the height column and not a numerical value. This will set the previous height as the same height of the current row.

2. create a new column outlier as boolean default FALSE

write the query that sets the value of outlier
if height > 2 * prev_height then outlier is True

3. inspect the results,

- does the threshold at 2 make sense ?

# CTEs on trees

For each arrondissement, find the top 3 tallest trees. Then, display these trees along with their circummference rank  within their arrondissement and their overall height rank in Paris.

```sql
WITH ranked_trees AS (
    SELECT
        l.arrondissement,
        t.idbase AS tree_id,
        t.height,
        t.circumference,
        ROW_NUMBER() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.height DESC
        ) AS height_rank_in_arrondissement,
        RANK() OVER (
            PARTITION BY l.arrondissement
            ORDER BY t.circumference DESC
        ) AS circumference_rank_in_arrondissement,
        RANK() OVER (
            ORDER BY t.height DESC
        ) AS overall_height_rank
    FROM trees t
    JOIN locations l ON t.location_id = l.id
)
SELECT
    arrondissement,
    tree_id,
    height,
    circumference,
    height_rank_in_arrondissement,
    circumference_rank_in_arrondissement,
    overall_height_rank
FROM ranked_trees
WHERE height_rank_in_arrondissement <= 3
ORDER BY arrondissement, height_rank_in_arrondissement;
```

It appears that name and genre are 1 to 1.
But some names are null for a given genre
For instance

  n   |     genre      |         name
-------+----------------+-----------------------
     2 | Abies          | [null]
   140 | Abies          | Sapin
     1 | Acacia         | [null]
    32 | Acacia         | Mimosa

How can we use CTEs to update the null values in the names column if there's a non null genre

```sql
WITH genre_name_mapping AS (
    SELECT
        tg.id AS genre_id,
        tg.genre,
        tn.id AS name_id,
        tn.name,
        ROW_NUMBER() OVER (PARTITION BY tg.genre ORDER BY tn.id) AS rn
    FROM tree_genres tg
    LEFT JOIN taxonomy tax ON tg.id = tax.genre_id
    LEFT JOIN tree_names tn ON tax.name_id = tn.id
),
valid_names AS (
    SELECT
        genre_id,
        genre,
        COALESCE(name, genre) AS valid_name
    FROM genre_name_mapping
    WHERE rn = 1
)
UPDATE tree_names tn
SET name = vn.valid_name
FROM taxonomy tax
JOIN valid_names vn ON tax.genre_id = vn.genre_id
WHERE tax.name_id = tn.id
  AND tn.name IS NULL;
```

# Further reading

CTEs on trees
<https://claude.ai/chat/fb6b9a94-b819-458a-8466-fe65d7b939c1>
