# Window function


see https://www.postgresql.org/docs/current/tutorial-window.html

What are Window functions and when to use them

Window Functions in SQL are also referred to as Analytic Function in some of the RDBMS.

SQL Window Functions covered in this video are RANK, DENSE RANK, ROW NUMBER, LEAD, LAG.

Also, we see how to use SQL Aggregate functions like MIN, MAX, SUM, COUNT, AVG as window function.

This document is focused on teaching how to write SQL Queries using different window functions or analytic functions.

We go through the syntax of using rank, dense_rank, row_number, lead, lag and max functions as window functions.

# Over clause and window functions
The OVER() clause is the main element to use  window function along with  Partition By and Order by clause.

Partition By clause is used to specify the column based on which different windows needs to be created.

The window function in the context of postgresql is applicable to any RDBMS since these functions are commonly used across most of the popular RDBMS such as Oracle, MySQL, PostgreSQL, Microsoft SQL Server etc.

## Plan

00:00 Intro
01:33 Understanding Aggregate function
03:16 Syntax to write SQL Query using Window Function
06:33 ROW_NUMBER() Window Function in SQL
11:57 RANK() Window Function in SQL
15:43 DENSE_RANK() Window Function in SQL
17:10 Difference between RANK, DENSE RANK and ROW NUMBER in SQL
17:59 LEAD() and LAG() Window Function in SQL


we work on the worldhits database in its denormalized version

# start

> psql into worldhitsdb on your local

We want to find the maximum popularity for all tracks.

```sql
select max(popularity) from tracks t
```

No we want to add that max_pop value as a column when returning all the rows.

```sql
select t.track, t.artist, t.popularity, (select max(popularity) from tracks t)  as max_pop  from tracks t;
```

We can have the same result by just adding the OVER() clause  in the previous query

```sql
select t.track, t.artist, t.popularity,
max(popularity) over() as max_pop
from tracks t ;
```

Now we want to find the max popularity for each artist but instead of just returning a 2 column results with max(pop) and artist name ...


```sql
select max(popularity) as max_pop, artist from tracks group by artist
```


| max_pop | artist |
|------|----|
| 36 | Afro Celt Sound System |
| 46 | Al Di Meola |
| 53 | Ali Farka Touré |

... we want to return all the rows in the db and add the extra max_pop column for each artist.

We want to have:

| id | artist | track | ... | max_pop |
|---|---|---|---|---|
| 301 |  Salif Keita | Sina |  ... | 32 |
| 302 |  Salif Keita | Tekere |  ... | 32 |
| 203 |  Jónsi | Tornado |  ... | 30 |
| 201 |  Jónsi | Kolniður |  ... | 30 |

This is where partiion by comes in

Partitioin by specifies the column on which you want to group by and apply the max() function on each sub group or sub partition



```sql
select t.track, t.artist, t.popularity,
max(popularity) over(partition by artist) as max_pop
from tracks t ;
```

It adds a max_pop column to the list of tracks.

In short, the OVER() clause specifies to SQL that you need to create a *a subset of records*
without specifying a column in the OVER clause, SQL creates one window function over all the records

the paritition by indicates with which column you want to group the subsets

In the above query,

over(partition by artist)  creates one window for all tracks (rows) for each given artist
and calculate the max(popularity) in each window

This worrks with other functions such as
- max(), min(), avg()

so we can combine them

```sql
select t.track, t.artist, t.popularity,
max(popularity) over(partition by artist) as max_pop,
min(popularity) over(partition by artist) as min_pop,
avg(popularity) over(partition by artist) as avg_pop
from tracks t ;
```


# row_number()

```row_number()``` assigns a unique value to the records in the window

Over all records

```sql
select t.id,  t.artist, t.track,
row_number() over() as rn
from tracks t limit 10;
```

we get exactly the same as the current id.

But if the id, the primary key was not sequentia, you could use that to generate a new primary key that is sequential.


more interestingly if we want to restart the row number per artist, we add partition by artist in the over clause:

```sql
select t.id, t.artist, t.track,
row_number() over(partition by artist) as rn
from tracks t
order by artist asc
limit 20;
```

the rn is reset to  1 for each artist.

@hen is that useful ?

Let's now fetch the 2  tracks with the highest tempo from each artist

by
- adding an order on tempo in the OVER clause
- putting these results in a subquery
- and adding a filter on rn


1. add order by tempo desc

```sql
select t.id, t.artist, t.track, t.tempo,
row_number() over(partition by artist order by tempo desc) as rn
from tracks t
order by artist asc;
```

2.  subquery and filter

```sql
select * from (
    select t.id, t.artist, t.track, t.tempo,
    row_number() over(partition by artist order by tempo desc) as rn
    from tracks t
    order by artist asc
    ) subset
where subset.rn < 3;
```

---------------
can we order and find the employee with the lowest / highest salary in each dept


can we combine column in partition as
for instance partition as species and arrondissement


### rank


fetch the  most popular tracks each year
```sql
select * from (
    select t.id, t.artist, t.track, t.year, t.popularity,
    row_number() over(partition by year order by popularity desc) as rn
    from tracks t) X
where X.rn < 3;

```

but using rank()

```sql
select t.id, t.artist, t.track, t.year, t.popularity,
rank() over(partition by year order by popularity desc) as rnk
from tracks t ;
```

equal values will have the same rank (see year 2005);

so rank can be 1, 2, 2, 4

so top most popular tracks per year

```sql
select * from (
    select t.id, t.artist, t.track, t.year, t.popularity,
    rank() over(partition by year order by popularity desc) as rnk
    from tracks t
) pop
where pop.rnk < 2;
```

1985 and 2005 have 2 tracks ex-aequo for most popular.



### dense_rank()
similar to rank
but will increment the rank without jumps in numbers

compare row_number(), rank() and dense_rank() in the following query

```sql
select t.id, t.artist, t.track, t.year, t.popularity,
row_number() over(partition by year order by popularity desc) as rn,
rank() over(partition by year order by popularity desc) as rnk,
dense_rank() over(partition by year order by popularity desc) as drnk
from tracks t
where t.year in (1985, 2005);
```

# And now a date
We need a date for the album release.
we could use id as proxy but ... meh :(;

Let's create a fake album release date using
- the row_number by year as the day
- and the month as random
- and the existing year

```sql
select t.id, t.track, t.year as rel_year,
floor(random() * 12 + 1) as rel_month,
row_number() over ( partition by t.year) as rel_day
from tracks t
order by album;
```

we need to add the release_date column as date to the tracks table

see https://www.postgresql.org/docs/current/datatype-datetime.html

```
ALTER TABLE tracks add column release_date DATE ;
```

and now to concatenate rel_year, rel_month, rel_day into a date string and cast it as a date using the above results as a subquery. we use the MAKE_DATE function in postgresql.

to get info on a function in postgresql you can ```\df function_name```:

```
\df make_date
```

returns
```bash
                                      List of functions
   Schema   |   Name    | Result data type |           Argument data types            | Type
------------+-----------+------------------+------------------------------------------+------
 pg_catalog | make_date | date             | year integer, month integer, day integer | func
```

Notice that the function accepts only INTs as input values.

So we need to cast the

And we use a CTE

```sql
WITH subquery AS (
    SELECT t.id, t.track,
           t.year as rel_year,
           floor(random() * 10 + 1)::int as rel_month,
           row_number() over (partition by t.year) as rel_day
    FROM tracks t
    ORDER BY album
)
UPDATE tracks
SET release_date = MAKE_DATE(rel_year::int, rel_month::int, rel_day::int)
FROM subquery
WHERE tracks.id = sq.id;
```

see what happens if you don't cast the rel_day, ... as int.

you get
```bash
ERROR:  42883: function make_date(integer, double precision, bigint) does not exist
```


ok now that we have a release date for each track we can demo lead() and lag()

## lead and lag

We want to find if the  popularity of a track is higher, lower or equal than the previously released  track

start with getting the popularity of tracks year by year

```sql
select t.id, t.track, t.release_date, t.popularity,
lag(popularity) over(partition by year order by release_date) as prev_track_pop
from tracks t
where year BETWEEN 1964 and  1970 ;
```

we see null values when the album was first that year
and the previous row popularity in the column ```prev_track_pop```


Now we can find out if the popularity was higher, lower or equal than the previously released track
year after year

```sql
select t.id, t.track, t.release_date, t.popularity,
case when t.popularity > lag(popularity) over(partition by year order by release_date) then 'higher'
when t.popularity < lag(popularity) over(partition by year order by release_date) then 'lower'
when t.popularity = lag(popularity) over(partition by year order by release_date) then 'equal'
else 'unknown'
END as pop_delta
from tracks t
where year BETWEEN 1964 and  1970;
```

lag and lead  take arguments:

lag(column)
lag(column, N rows)
lag(column, N rows, default value)

lag(popularity, 2, 0) looks 2 rows before and 0 is a default value

lead is the same: rows following the current record

# Application to the tree table



